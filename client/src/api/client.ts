//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { ClientBase } from './clientbase';

export class Client extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://localhost:44323/", baseUrl);
    }

    /**
     * @return OK
     */
    getCategories(): Promise<CategoryResponse[]> {
        let url_ = this.baseUrl + "/api/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: Response): Promise<CategoryResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    client(): Promise<void> {
        let url_ = this.baseUrl + "/api/config/client";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processClient(_response);
        });
    }

    protected processClient(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    reviewContent(contentId: string, body: ReviewRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentId}/review";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReviewContent(_response);
        });
    }

    protected processReviewContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    images(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/content/images/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImages(_response);
        });
    }

    protected processImages(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    searchContent(body: SearchContentRequest): Promise<SearchContentResponse> {
        let url_ = this.baseUrl + "/api/content/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchContent(_response);
        });
    }

    protected processSearchContent(response: Response): Promise<SearchContentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchContentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchContentResponse>(null as any);
    }

    /**
     * @return OK
     */
    getPossibleDuplicates(): Promise<PossibleDuplicateResponse[]> {
        let url_ = this.baseUrl + "/api/content/duplicates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPossibleDuplicates(_response);
        });
    }

    protected processGetPossibleDuplicates(response: Response): Promise<PossibleDuplicateResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PossibleDuplicateResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PossibleDuplicateResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    mergeContent(body: MergeContentRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/content/merge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMergeContent(_response);
        });
    }

    protected processMergeContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getGroups(): Promise<GroupResponse[]> {
        let url_ = this.baseUrl + "/api/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroups(_response);
        });
    }

    protected processGetGroups(response: Response): Promise<GroupResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupResponse[]>(null as any);
    }

    /**
     * @return Created
     */
    createGroup(body: GroupRequest): Promise<GroupResponse> {
        let url_ = this.baseUrl + "/api/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateGroup(_response);
        });
    }

    protected processCreateGroup(response: Response): Promise<GroupResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GroupResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupResponse>(null as any);
    }

    /**
     * @return OK
     */
    getGroup(id: string): Promise<GroupResponse> {
        let url_ = this.baseUrl + "/api/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroup(_response);
        });
    }

    protected processGetGroup(response: Response): Promise<GroupResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupResponse>(null as any);
    }

    /**
     * @return OK
     */
    updateGroup(id: string, body: GroupRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateGroup(_response);
        });
    }

    protected processUpdateGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteGroup(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteGroup(_response);
        });
    }

    protected processDeleteGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getGroupContent(groupId: string): Promise<ContentResponse[]> {
        let url_ = this.baseUrl + "/api/groups/{groupId}/content";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupContent(_response);
        });
    }

    protected processGetGroupContent(response: Response): Promise<ContentResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    joinGroup(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/groups/{id}/join";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processJoinGroup(_response);
        });
    }

    protected processJoinGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    changeMemberState(id: string, userId: string, body: ChangeMemberStateRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/groups/{id}/users/{userId}/state";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangeMemberState(_response);
        });
    }

    protected processChangeMemberState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param pageSize (optional)
     * @param offset (optional)
     * @return OK
     */
    getGroupSuggestions(groupId: string, pageSize: number | undefined, offset: number | undefined): Promise<GroupSuggestionsResponse> {
        let url_ = this.baseUrl + "/api/groups/{groupId}/suggestions?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupSuggestions(_response);
        });
    }

    protected processGetGroupSuggestions(response: Response): Promise<GroupSuggestionsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupSuggestionsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupSuggestionsResponse>(null as any);
    }

    /**
     * @return OK
     */
    getServices(): Promise<ServiceResponse[]> {
        let url_ = this.baseUrl + "/api/services";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetServices(_response);
        });
    }

    protected processGetServices(response: Response): Promise<ServiceResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    ensureUser(): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/user/ensure";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEnsureUser(_response);
        });
    }

    protected processEnsureUser(response: Response): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    /**
     * @return OK
     */
    getProfile(): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    /**
     * @return OK
     */
    updateProfile(body: UserRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProfile(_response);
        });
    }

    protected processUpdateProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteProfile(): Promise<void> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProfile(_response);
        });
    }

    protected processDeleteProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CategoryResponse implements ICategoryResponse {
    id?: string;
    name?: string;

    [key: string]: any;

    constructor(data?: ICategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryResponse {
    id?: string;
    name?: string;

    [key: string]: any;
}

export class ChangeMemberStateRequest implements IChangeMemberStateRequest {
    state?: GroupMemberStatus;

    [key: string]: any;

    constructor(data?: IChangeMemberStateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ChangeMemberStateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeMemberStateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["state"] = this.state;
        return data;
    }
}

export interface IChangeMemberStateRequest {
    state?: GroupMemberStatus;

    [key: string]: any;
}

export class ContentAvailabilityResponse implements IContentAvailabilityResponse {
    serviceId?: string;
    serviceName?: string;
    serviceLogo?: string;
    ranking?: number | undefined;

    [key: string]: any;

    constructor(data?: IContentAvailabilityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.serviceId = _data["serviceId"];
            this.serviceName = _data["serviceName"];
            this.serviceLogo = _data["serviceLogo"];
            this.ranking = _data["ranking"];
        }
    }

    static fromJS(data: any): ContentAvailabilityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContentAvailabilityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["serviceId"] = this.serviceId;
        data["serviceName"] = this.serviceName;
        data["serviceLogo"] = this.serviceLogo;
        data["ranking"] = this.ranking;
        return data;
    }
}

export interface IContentAvailabilityResponse {
    serviceId?: string;
    serviceName?: string;
    serviceLogo?: string;
    ranking?: number | undefined;

    [key: string]: any;
}

export class ContentResponse implements IContentResponse {
    id?: string;
    type?: number;
    title?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    clipUrl?: string | undefined;
    releaseYear?: number | undefined;
    runtime?: number | undefined;
    likeCount?: number | undefined;
    dislikeCount?: number | undefined;
    imdbVotes?: number | undefined;
    imdbScore?: number | undefined;
    tmdbPopularity?: number | undefined;
    tmdbScore?: number | undefined;
    tomatoMeter?: number | undefined;
    justWatchRating?: number | undefined;
    languages?: string[];
    cast?: string[];
    categories?: CategoryResponse[];
    availabilities?: ContentAvailabilityResponse[];

    [key: string]: any;

    constructor(data?: IContentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.shortDescription = _data["shortDescription"];
            this.imageUrl = _data["imageUrl"];
            this.clipUrl = _data["clipUrl"];
            this.releaseYear = _data["releaseYear"];
            this.runtime = _data["runtime"];
            this.likeCount = _data["likeCount"];
            this.dislikeCount = _data["dislikeCount"];
            this.imdbVotes = _data["imdbVotes"];
            this.imdbScore = _data["imdbScore"];
            this.tmdbPopularity = _data["tmdbPopularity"];
            this.tmdbScore = _data["tmdbScore"];
            this.tomatoMeter = _data["tomatoMeter"];
            this.justWatchRating = _data["justWatchRating"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            if (Array.isArray(_data["cast"])) {
                this.cast = [] as any;
                for (let item of _data["cast"])
                    this.cast!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryResponse.fromJS(item));
            }
            if (Array.isArray(_data["availabilities"])) {
                this.availabilities = [] as any;
                for (let item of _data["availabilities"])
                    this.availabilities!.push(ContentAvailabilityResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["shortDescription"] = this.shortDescription;
        data["imageUrl"] = this.imageUrl;
        data["clipUrl"] = this.clipUrl;
        data["releaseYear"] = this.releaseYear;
        data["runtime"] = this.runtime;
        data["likeCount"] = this.likeCount;
        data["dislikeCount"] = this.dislikeCount;
        data["imdbVotes"] = this.imdbVotes;
        data["imdbScore"] = this.imdbScore;
        data["tmdbPopularity"] = this.tmdbPopularity;
        data["tmdbScore"] = this.tmdbScore;
        data["tomatoMeter"] = this.tomatoMeter;
        data["justWatchRating"] = this.justWatchRating;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        if (Array.isArray(this.cast)) {
            data["cast"] = [];
            for (let item of this.cast)
                data["cast"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.availabilities)) {
            data["availabilities"] = [];
            for (let item of this.availabilities)
                data["availabilities"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IContentResponse {
    id?: string;
    type?: number;
    title?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    clipUrl?: string | undefined;
    releaseYear?: number | undefined;
    runtime?: number | undefined;
    likeCount?: number | undefined;
    dislikeCount?: number | undefined;
    imdbVotes?: number | undefined;
    imdbScore?: number | undefined;
    tmdbPopularity?: number | undefined;
    tmdbScore?: number | undefined;
    tomatoMeter?: number | undefined;
    justWatchRating?: number | undefined;
    languages?: string[];
    cast?: string[];
    categories?: CategoryResponse[];
    availabilities?: ContentAvailabilityResponse[];

    [key: string]: any;
}

export enum ContentSorting {
    None = "None",
    Alphabetical = "Alphabetical",
    MostPopular = "MostPopular",
    YearAscending = "YearAscending",
    YearDescending = "YearDescending",
    ImdbRating = "ImdbRating",
    TmdbRating = "TmdbRating",
    MyRatingAscending = "MyRatingAscending",
    MyRatingDescending = "MyRatingDescending",
    MyRatingTimeAscending = "MyRatingTimeAscending",
    MyRatingTimeDescending = "MyRatingTimeDescending",
}

export enum GroupMemberStatus {
    None = "None",
    Pending = "Pending",
    Approved = "Approved",
    Rejected = "Rejected",
}

export class GroupRequest implements IGroupRequest {
    name?: string;
    requireApproval?: boolean;
    settings?: GroupSettings2 | undefined;

    [key: string]: any;

    constructor(data?: IGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.requireApproval = _data["requireApproval"];
            this.settings = _data["settings"] ? GroupSettings2.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["requireApproval"] = this.requireApproval;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroupRequest {
    name?: string;
    requireApproval?: boolean;
    settings?: GroupSettings2 | undefined;

    [key: string]: any;
}

export class GroupResponse implements IGroupResponse {
    id?: string;
    name?: string;
    creatorId?: string;
    settings?: GroupSettings;
    memberCount?: number;
    requireApproval?: boolean;
    isMember?: boolean;
    isCreator?: boolean;
    shareLink?: string;
    members?: MemberResponse[];

    [key: string]: any;

    constructor(data?: IGroupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.creatorId = _data["creatorId"];
            this.settings = _data["settings"] ? GroupSettings.fromJS(_data["settings"]) : <any>undefined;
            this.memberCount = _data["memberCount"];
            this.requireApproval = _data["requireApproval"];
            this.isMember = _data["isMember"];
            this.isCreator = _data["isCreator"];
            this.shareLink = _data["shareLink"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(MemberResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GroupResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["creatorId"] = this.creatorId;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        data["memberCount"] = this.memberCount;
        data["requireApproval"] = this.requireApproval;
        data["isMember"] = this.isMember;
        data["isCreator"] = this.isCreator;
        data["shareLink"] = this.shareLink;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IGroupResponse {
    id?: string;
    name?: string;
    creatorId?: string;
    settings?: GroupSettings;
    memberCount?: number;
    requireApproval?: boolean;
    isMember?: boolean;
    isCreator?: boolean;
    shareLink?: string;
    members?: MemberResponse[];

    [key: string]: any;
}

export class GroupSettings implements IGroupSettings {
    services?: string[] | undefined;
    contentTypes?: number[];
    categories?: string[] | undefined;
    releaseYear?: GroupSettingsRangeOfNullableOfint | undefined;
    imdbVotes?: GroupSettingsRangeOfNullableOflong | undefined;
    imdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbPopularity?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tomatoMeter?: GroupSettingsRangeOfNullableOfint | undefined;
    justWatchRating?: GroupSettingsRangeOfNullableOfdouble | undefined;

    [key: string]: any;

    constructor(data?: IGroupSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(item);
            }
            if (Array.isArray(_data["contentTypes"])) {
                this.contentTypes = [] as any;
                for (let item of _data["contentTypes"])
                    this.contentTypes!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            this.releaseYear = _data["releaseYear"] ? GroupSettingsRangeOfNullableOfint.fromJS(_data["releaseYear"]) : <any>undefined;
            this.imdbVotes = _data["imdbVotes"] ? GroupSettingsRangeOfNullableOflong.fromJS(_data["imdbVotes"]) : <any>undefined;
            this.imdbScore = _data["imdbScore"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["imdbScore"]) : <any>undefined;
            this.tmdbPopularity = _data["tmdbPopularity"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["tmdbPopularity"]) : <any>undefined;
            this.tmdbScore = _data["tmdbScore"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["tmdbScore"]) : <any>undefined;
            this.tomatoMeter = _data["tomatoMeter"] ? GroupSettingsRangeOfNullableOfint.fromJS(_data["tomatoMeter"]) : <any>undefined;
            this.justWatchRating = _data["justWatchRating"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["justWatchRating"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item);
        }
        if (Array.isArray(this.contentTypes)) {
            data["contentTypes"] = [];
            for (let item of this.contentTypes)
                data["contentTypes"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["releaseYear"] = this.releaseYear ? this.releaseYear.toJSON() : <any>undefined;
        data["imdbVotes"] = this.imdbVotes ? this.imdbVotes.toJSON() : <any>undefined;
        data["imdbScore"] = this.imdbScore ? this.imdbScore.toJSON() : <any>undefined;
        data["tmdbPopularity"] = this.tmdbPopularity ? this.tmdbPopularity.toJSON() : <any>undefined;
        data["tmdbScore"] = this.tmdbScore ? this.tmdbScore.toJSON() : <any>undefined;
        data["tomatoMeter"] = this.tomatoMeter ? this.tomatoMeter.toJSON() : <any>undefined;
        data["justWatchRating"] = this.justWatchRating ? this.justWatchRating.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroupSettings {
    services?: string[] | undefined;
    contentTypes?: number[];
    categories?: string[] | undefined;
    releaseYear?: GroupSettingsRangeOfNullableOfint | undefined;
    imdbVotes?: GroupSettingsRangeOfNullableOflong | undefined;
    imdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbPopularity?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tomatoMeter?: GroupSettingsRangeOfNullableOfint | undefined;
    justWatchRating?: GroupSettingsRangeOfNullableOfdouble | undefined;

    [key: string]: any;
}

export class GroupSettings2 implements IGroupSettings2 {
    services?: string[] | undefined;
    contentTypes?: number[];
    categories?: string[] | undefined;
    releaseYear?: GroupSettingsRangeOfNullableOfint | undefined;
    imdbVotes?: GroupSettingsRangeOfNullableOflong | undefined;
    imdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbPopularity?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tomatoMeter?: GroupSettingsRangeOfNullableOfint | undefined;
    justWatchRating?: GroupSettingsRangeOfNullableOfdouble | undefined;

    [key: string]: any;

    constructor(data?: IGroupSettings2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(item);
            }
            if (Array.isArray(_data["contentTypes"])) {
                this.contentTypes = [] as any;
                for (let item of _data["contentTypes"])
                    this.contentTypes!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            this.releaseYear = _data["releaseYear"] ? GroupSettingsRangeOfNullableOfint.fromJS(_data["releaseYear"]) : <any>undefined;
            this.imdbVotes = _data["imdbVotes"] ? GroupSettingsRangeOfNullableOflong.fromJS(_data["imdbVotes"]) : <any>undefined;
            this.imdbScore = _data["imdbScore"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["imdbScore"]) : <any>undefined;
            this.tmdbPopularity = _data["tmdbPopularity"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["tmdbPopularity"]) : <any>undefined;
            this.tmdbScore = _data["tmdbScore"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["tmdbScore"]) : <any>undefined;
            this.tomatoMeter = _data["tomatoMeter"] ? GroupSettingsRangeOfNullableOfint.fromJS(_data["tomatoMeter"]) : <any>undefined;
            this.justWatchRating = _data["justWatchRating"] ? GroupSettingsRangeOfNullableOfdouble.fromJS(_data["justWatchRating"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupSettings2 {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSettings2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item);
        }
        if (Array.isArray(this.contentTypes)) {
            data["contentTypes"] = [];
            for (let item of this.contentTypes)
                data["contentTypes"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["releaseYear"] = this.releaseYear ? this.releaseYear.toJSON() : <any>undefined;
        data["imdbVotes"] = this.imdbVotes ? this.imdbVotes.toJSON() : <any>undefined;
        data["imdbScore"] = this.imdbScore ? this.imdbScore.toJSON() : <any>undefined;
        data["tmdbPopularity"] = this.tmdbPopularity ? this.tmdbPopularity.toJSON() : <any>undefined;
        data["tmdbScore"] = this.tmdbScore ? this.tmdbScore.toJSON() : <any>undefined;
        data["tomatoMeter"] = this.tomatoMeter ? this.tomatoMeter.toJSON() : <any>undefined;
        data["justWatchRating"] = this.justWatchRating ? this.justWatchRating.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroupSettings2 {
    services?: string[] | undefined;
    contentTypes?: number[];
    categories?: string[] | undefined;
    releaseYear?: GroupSettingsRangeOfNullableOfint | undefined;
    imdbVotes?: GroupSettingsRangeOfNullableOflong | undefined;
    imdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbPopularity?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tmdbScore?: GroupSettingsRangeOfNullableOfdouble | undefined;
    tomatoMeter?: GroupSettingsRangeOfNullableOfint | undefined;
    justWatchRating?: GroupSettingsRangeOfNullableOfdouble | undefined;

    [key: string]: any;
}

export class GroupSettingsRangeOfNullableOfdouble implements IGroupSettingsRangeOfNullableOfdouble {
    min?: number | undefined;
    max?: number | undefined;

    [key: string]: any;

    constructor(data?: IGroupSettingsRangeOfNullableOfdouble) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): GroupSettingsRangeOfNullableOfdouble {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSettingsRangeOfNullableOfdouble();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["min"] = this.min;
        data["max"] = this.max;
        return data;
    }
}

export interface IGroupSettingsRangeOfNullableOfdouble {
    min?: number | undefined;
    max?: number | undefined;

    [key: string]: any;
}

export class GroupSettingsRangeOfNullableOfint implements IGroupSettingsRangeOfNullableOfint {
    min?: number | undefined;
    max?: number | undefined;

    [key: string]: any;

    constructor(data?: IGroupSettingsRangeOfNullableOfint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): GroupSettingsRangeOfNullableOfint {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSettingsRangeOfNullableOfint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["min"] = this.min;
        data["max"] = this.max;
        return data;
    }
}

export interface IGroupSettingsRangeOfNullableOfint {
    min?: number | undefined;
    max?: number | undefined;

    [key: string]: any;
}

export class GroupSettingsRangeOfNullableOflong implements IGroupSettingsRangeOfNullableOflong {
    min?: number | undefined;
    max?: number | undefined;

    [key: string]: any;

    constructor(data?: IGroupSettingsRangeOfNullableOflong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): GroupSettingsRangeOfNullableOflong {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSettingsRangeOfNullableOflong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["min"] = this.min;
        data["max"] = this.max;
        return data;
    }
}

export interface IGroupSettingsRangeOfNullableOflong {
    min?: number | undefined;
    max?: number | undefined;

    [key: string]: any;
}

export class GroupSuggestion implements IGroupSuggestion {
    ratingCount?: number;
    totalScore?: number;
    weightedScore?: number;
    id?: string;
    type?: number;
    title?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    clipUrl?: string | undefined;
    releaseYear?: number | undefined;
    runtime?: number | undefined;
    likeCount?: number | undefined;
    dislikeCount?: number | undefined;
    imdbVotes?: number | undefined;
    imdbScore?: number | undefined;
    tmdbPopularity?: number | undefined;
    tmdbScore?: number | undefined;
    tomatoMeter?: number | undefined;
    justWatchRating?: number | undefined;
    languages?: string[];
    cast?: string[];
    categories?: CategoryResponse[];
    availabilities?: ContentAvailabilityResponse[];

    [key: string]: any;

    constructor(data?: IGroupSuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ratingCount = _data["ratingCount"];
            this.totalScore = _data["totalScore"];
            this.weightedScore = _data["weightedScore"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.shortDescription = _data["shortDescription"];
            this.imageUrl = _data["imageUrl"];
            this.clipUrl = _data["clipUrl"];
            this.releaseYear = _data["releaseYear"];
            this.runtime = _data["runtime"];
            this.likeCount = _data["likeCount"];
            this.dislikeCount = _data["dislikeCount"];
            this.imdbVotes = _data["imdbVotes"];
            this.imdbScore = _data["imdbScore"];
            this.tmdbPopularity = _data["tmdbPopularity"];
            this.tmdbScore = _data["tmdbScore"];
            this.tomatoMeter = _data["tomatoMeter"];
            this.justWatchRating = _data["justWatchRating"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            if (Array.isArray(_data["cast"])) {
                this.cast = [] as any;
                for (let item of _data["cast"])
                    this.cast!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryResponse.fromJS(item));
            }
            if (Array.isArray(_data["availabilities"])) {
                this.availabilities = [] as any;
                for (let item of _data["availabilities"])
                    this.availabilities!.push(ContentAvailabilityResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupSuggestion {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSuggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ratingCount"] = this.ratingCount;
        data["totalScore"] = this.totalScore;
        data["weightedScore"] = this.weightedScore;
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["shortDescription"] = this.shortDescription;
        data["imageUrl"] = this.imageUrl;
        data["clipUrl"] = this.clipUrl;
        data["releaseYear"] = this.releaseYear;
        data["runtime"] = this.runtime;
        data["likeCount"] = this.likeCount;
        data["dislikeCount"] = this.dislikeCount;
        data["imdbVotes"] = this.imdbVotes;
        data["imdbScore"] = this.imdbScore;
        data["tmdbPopularity"] = this.tmdbPopularity;
        data["tmdbScore"] = this.tmdbScore;
        data["tomatoMeter"] = this.tomatoMeter;
        data["justWatchRating"] = this.justWatchRating;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        if (Array.isArray(this.cast)) {
            data["cast"] = [];
            for (let item of this.cast)
                data["cast"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.availabilities)) {
            data["availabilities"] = [];
            for (let item of this.availabilities)
                data["availabilities"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IGroupSuggestion {
    ratingCount?: number;
    totalScore?: number;
    weightedScore?: number;
    id?: string;
    type?: number;
    title?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    clipUrl?: string | undefined;
    releaseYear?: number | undefined;
    runtime?: number | undefined;
    likeCount?: number | undefined;
    dislikeCount?: number | undefined;
    imdbVotes?: number | undefined;
    imdbScore?: number | undefined;
    tmdbPopularity?: number | undefined;
    tmdbScore?: number | undefined;
    tomatoMeter?: number | undefined;
    justWatchRating?: number | undefined;
    languages?: string[];
    cast?: string[];
    categories?: CategoryResponse[];
    availabilities?: ContentAvailabilityResponse[];

    [key: string]: any;
}

export class GroupSuggestionsResponse implements IGroupSuggestionsResponse {
    items?: GroupSuggestion[];
    totalCount?: number;

    [key: string]: any;

    constructor(data?: IGroupSuggestionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupSuggestion.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GroupSuggestionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSuggestionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGroupSuggestionsResponse {
    items?: GroupSuggestion[];
    totalCount?: number;

    [key: string]: any;
}

export class MemberResponse implements IMemberResponse {
    id?: string;
    name?: string;
    status?: GroupMemberStatus;

    [key: string]: any;

    constructor(data?: IMemberResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): MemberResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MemberResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        return data;
    }
}

export interface IMemberResponse {
    id?: string;
    name?: string;
    status?: GroupMemberStatus;

    [key: string]: any;
}

export class MergeContentRequest implements IMergeContentRequest {
    contentIds?: string[];
    descriptionContentId?: string;

    [key: string]: any;

    constructor(data?: IMergeContentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
            this.descriptionContentId = _data["descriptionContentId"];
        }
    }

    static fromJS(data: any): MergeContentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MergeContentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["descriptionContentId"] = this.descriptionContentId;
        return data;
    }
}

export interface IMergeContentRequest {
    contentIds?: string[];
    descriptionContentId?: string;

    [key: string]: any;
}

export class PossibleDuplicateItem implements IPossibleDuplicateItem {
    id?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;

    [key: string]: any;

    constructor(data?: IPossibleDuplicateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.shortDescription = _data["shortDescription"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): PossibleDuplicateItem {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleDuplicateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["shortDescription"] = this.shortDescription;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IPossibleDuplicateItem {
    id?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;

    [key: string]: any;
}

export class PossibleDuplicateResponse implements IPossibleDuplicateResponse {
    type?: number;
    title?: string;
    releaseYear?: number | undefined;
    items?: PossibleDuplicateItem[];

    [key: string]: any;

    constructor(data?: IPossibleDuplicateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.releaseYear = _data["releaseYear"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PossibleDuplicateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PossibleDuplicateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleDuplicateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["releaseYear"] = this.releaseYear;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPossibleDuplicateResponse {
    type?: number;
    title?: string;
    releaseYear?: number | undefined;
    items?: PossibleDuplicateItem[];

    [key: string]: any;
}

export class ReviewRequest implements IReviewRequest {
    rating!: number;
    type!: number;

    [key: string]: any;

    constructor(data?: IReviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.rating = _data["rating"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["rating"] = this.rating;
        data["type"] = this.type;
        return data;
    }
}

export interface IReviewRequest {
    rating: number;
    type: number;

    [key: string]: any;
}

export class SearchContentRequest implements ISearchContentRequest {
    services?: string[] | undefined;
    contentTypes?: number[] | undefined;
    categories?: string[] | undefined;
    reviewed?: boolean | undefined;
    notReviewed?: boolean | undefined;
    ratings?: number[] | undefined;
    sortBy?: ContentSorting;
    pageSize?: number | undefined;
    offset?: number | undefined;
    title?: string | undefined;

    [key: string]: any;

    constructor(data?: ISearchContentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(item);
            }
            if (Array.isArray(_data["contentTypes"])) {
                this.contentTypes = [] as any;
                for (let item of _data["contentTypes"])
                    this.contentTypes!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            this.reviewed = _data["reviewed"];
            this.notReviewed = _data["notReviewed"];
            if (Array.isArray(_data["ratings"])) {
                this.ratings = [] as any;
                for (let item of _data["ratings"])
                    this.ratings!.push(item);
            }
            this.sortBy = _data["sortBy"];
            this.pageSize = _data["pageSize"];
            this.offset = _data["offset"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): SearchContentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchContentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item);
        }
        if (Array.isArray(this.contentTypes)) {
            data["contentTypes"] = [];
            for (let item of this.contentTypes)
                data["contentTypes"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["reviewed"] = this.reviewed;
        data["notReviewed"] = this.notReviewed;
        if (Array.isArray(this.ratings)) {
            data["ratings"] = [];
            for (let item of this.ratings)
                data["ratings"].push(item);
        }
        data["sortBy"] = this.sortBy;
        data["pageSize"] = this.pageSize;
        data["offset"] = this.offset;
        data["title"] = this.title;
        return data;
    }
}

export interface ISearchContentRequest {
    services?: string[] | undefined;
    contentTypes?: number[] | undefined;
    categories?: string[] | undefined;
    reviewed?: boolean | undefined;
    notReviewed?: boolean | undefined;
    ratings?: number[] | undefined;
    sortBy?: ContentSorting;
    pageSize?: number | undefined;
    offset?: number | undefined;
    title?: string | undefined;

    [key: string]: any;
}

export class SearchContentResponse implements ISearchContentResponse {
    items?: UserContentResponse[];
    totalCount?: number;

    [key: string]: any;

    constructor(data?: ISearchContentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserContentResponse.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SearchContentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchContentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ISearchContentResponse {
    items?: UserContentResponse[];
    totalCount?: number;

    [key: string]: any;
}

export class ServiceResponse implements IServiceResponse {
    id?: string;
    name?: string;
    logo?: string;

    [key: string]: any;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.logo = _data["logo"];
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["logo"] = this.logo;
        return data;
    }
}

export interface IServiceResponse {
    id?: string;
    name?: string;
    logo?: string;

    [key: string]: any;
}

export class UserContentResponse implements IUserContentResponse {
    userRating?: number | undefined;
    userRatingTime?: Date | undefined;
    id?: string;
    type?: number;
    title?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    clipUrl?: string | undefined;
    releaseYear?: number | undefined;
    runtime?: number | undefined;
    likeCount?: number | undefined;
    dislikeCount?: number | undefined;
    imdbVotes?: number | undefined;
    imdbScore?: number | undefined;
    tmdbPopularity?: number | undefined;
    tmdbScore?: number | undefined;
    tomatoMeter?: number | undefined;
    justWatchRating?: number | undefined;
    languages?: string[];
    cast?: string[];
    categories?: CategoryResponse[];
    availabilities?: ContentAvailabilityResponse[];

    [key: string]: any;

    constructor(data?: IUserContentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userRating = _data["userRating"];
            this.userRatingTime = _data["userRatingTime"] ? new Date(_data["userRatingTime"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.shortDescription = _data["shortDescription"];
            this.imageUrl = _data["imageUrl"];
            this.clipUrl = _data["clipUrl"];
            this.releaseYear = _data["releaseYear"];
            this.runtime = _data["runtime"];
            this.likeCount = _data["likeCount"];
            this.dislikeCount = _data["dislikeCount"];
            this.imdbVotes = _data["imdbVotes"];
            this.imdbScore = _data["imdbScore"];
            this.tmdbPopularity = _data["tmdbPopularity"];
            this.tmdbScore = _data["tmdbScore"];
            this.tomatoMeter = _data["tomatoMeter"];
            this.justWatchRating = _data["justWatchRating"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            if (Array.isArray(_data["cast"])) {
                this.cast = [] as any;
                for (let item of _data["cast"])
                    this.cast!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryResponse.fromJS(item));
            }
            if (Array.isArray(_data["availabilities"])) {
                this.availabilities = [] as any;
                for (let item of _data["availabilities"])
                    this.availabilities!.push(ContentAvailabilityResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserContentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserContentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userRating"] = this.userRating;
        data["userRatingTime"] = this.userRatingTime ? this.userRatingTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["shortDescription"] = this.shortDescription;
        data["imageUrl"] = this.imageUrl;
        data["clipUrl"] = this.clipUrl;
        data["releaseYear"] = this.releaseYear;
        data["runtime"] = this.runtime;
        data["likeCount"] = this.likeCount;
        data["dislikeCount"] = this.dislikeCount;
        data["imdbVotes"] = this.imdbVotes;
        data["imdbScore"] = this.imdbScore;
        data["tmdbPopularity"] = this.tmdbPopularity;
        data["tmdbScore"] = this.tmdbScore;
        data["tomatoMeter"] = this.tomatoMeter;
        data["justWatchRating"] = this.justWatchRating;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        if (Array.isArray(this.cast)) {
            data["cast"] = [];
            for (let item of this.cast)
                data["cast"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.availabilities)) {
            data["availabilities"] = [];
            for (let item of this.availabilities)
                data["availabilities"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUserContentResponse {
    userRating?: number | undefined;
    userRatingTime?: Date | undefined;
    id?: string;
    type?: number;
    title?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    clipUrl?: string | undefined;
    releaseYear?: number | undefined;
    runtime?: number | undefined;
    likeCount?: number | undefined;
    dislikeCount?: number | undefined;
    imdbVotes?: number | undefined;
    imdbScore?: number | undefined;
    tmdbPopularity?: number | undefined;
    tmdbScore?: number | undefined;
    tomatoMeter?: number | undefined;
    justWatchRating?: number | undefined;
    languages?: string[];
    cast?: string[];
    categories?: CategoryResponse[];
    availabilities?: ContentAvailabilityResponse[];

    [key: string]: any;
}

export class UserRequest implements IUserRequest {
    name?: string | undefined;
    email?: string | undefined;

    [key: string]: any;

    constructor(data?: IUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserRequest {
    name?: string | undefined;
    email?: string | undefined;

    [key: string]: any;
}

export class UserResponse implements IUserResponse {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    isAdmin?: boolean;

    [key: string]: any;

    constructor(data?: IUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.isAdmin = _data["isAdmin"];
        }
    }

    static fromJS(data: any): UserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["isAdmin"] = this.isAdmin;
        return data;
    }
}

export interface IUserResponse {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    isAdmin?: boolean;

    [key: string]: any;
}

export class ApiException extends Error {
    //message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable no-prototype-builtins */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
